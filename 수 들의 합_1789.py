n = int(input())

# 이분탐색을 사용하면 O(log n)이라는 시간이 걸린다
low = 1
mid = 0
high = n
ans = 0
while low <= high:
    mid = (low + high) // 2
    if mid * (mid + 1) // 2 <= n:
        ans = mid
        low = mid + 1
    else:
        high = mid - 1
print(ans)

# n(n+1)/2 <= S를 근의 공식을 적용하면, (-1 +- 루트(1+8s))//2
# 따라서 최대의 값인 (루트(1+8s) - 1)//2을 구하면 된다
# 실행시간은 단순 계산이므로 O(1)
print(int(((1 + 8 * n) ** 0.5 - 1)) // 2)


"""
n - (i*(i+1)//2) 를 하면 항상 (i*(i+1)//2)보다 작다
따라서 맨 마지막에 나온 숫자가 정답이 된다
왜냐하면 결국 문제에서 요구한 최대값은 i가 몇번째 수냐 다
만약 n이 200이라면 사실 맨 마지막수는 29가 되는데,
결국 19에 10을 더한것과 같으므로 최댓값은 19가 된다
19의 뒤에 10이 올 수 없으므로, 결국 맨마지막 수는 29가 되고
최댓값은 19가 된다
정 헷갈리면 배열에 삽입해보면 이해하기 쉬울거다
만약 입력한 숫자가 매우 큰숫자이면 O(n)이므로 아주 오래걸린다
"""
i = 1
while i * (i + 1) // 2 <= n:
    i += 1
print(i-1)
